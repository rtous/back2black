#ifndef __DATASTRUCTURES_H__
#define __DATASTRUCTURES_H__

#define MAX_MASKS_IDS 1000

#include <opencv2/opencv.hpp> 
#include "sam.h"
#include <SDL_opengl.h>

/*
	- A video is composed by frames
	- A frame is composed by masks
	- An mask has one-to-many contours (example: tshirt if the arm divides it)
*/ 

class Contour {      
  public:             
    std::vector<cv::Point> contourPoints;
    cv::Point contourCenter;
};

//class Mask {      
class Mask {      
  public:             
    //pixels
    cv::Mat opencv_mask;//generated by compute_mask in common1.cpp. Used by the editor?
    cv::Mat opencv_mask_simplified;//generated by compute_mask_textures along with simplifiedMaskTexture. Later all the masks are mixed together in simplify_segmented_frame
    sam_image_u8 samMask; //mask in sam format
    bool mask_computed = false;
    GLuint maskTexture; //mask in OpenGL
    GLuint simplifiedMaskTexture; //simplified mask in OpenGL
    bool textures_computed = false;
    bool visible = true;
    bool track_movement = true;
    

    //contours
    //WHO's using this??
    std::vector<std::vector<cv::Point>> contours;//contours of the mask generated by compute_mask_center

    std::vector<std::vector<cv::Point>> simplifiedContours;//contours of the simplified mask

  
    
    int maskId;
    //int color;
    float color[4]; //R,G,B,A (WARNING: values between 0 and 1)
    int mask_computed_at_x = -1;  
    int mask_computed_at_y = -1;
    int mask_center_x = -1;  
    int mask_center_y = -1; 
    int mask_contour_size;

    Mask() {
      //Default color
      color[0] = (rand() % 256)/(float)256;
      color[1] = (rand() % 256)/(float)256;
      color[2] = (rand() % 256)/(float)256;
      color[3] = 0.0f;//no transparency
    }
};

class Frame {      
  public:             
    int order; //from 0 to N-1 
    bool loaded = false;
    std::string filePath; //when the input is a directory of images instead of a video (only used to keep the filenames in the output in cli_masks)
    std::vector<Mask> masks; 
    cv::Mat img; //OpenCV format (WARNING: original, not downscaled. The img_sam_format is scaled in video.cpp)
    cv::Mat img_simplified; //OpenCV format (just keep the texture)
    cv::Mat faces; //OpenCV format (faces mask)
    cv::Mat eyes; //OpenCV format (eyes mask)
    //NOTE: These two hold the current image.
    //      A copy of the image in the selected frame (both in the video and single image case)
    //      I think I should remove them
    sam_image_u8 img_sam_format; //the video frame in sam format (downscaled to window size)
    sam_image_u8 img_sam_format_downscaled; //the video frame in sam format (downscaled to window size)
    GLuint tex; //OpenGL texture of the original video frame
    GLuint tex_simplified; //OpenGL texture of simplified masks
    GLuint facesTexture;//OpenGL texture of the faces
    GLuint eyesTexture;//OpenGL texture of the eyes
    bool faces_check = false;
    bool faces_computed = false;
    bool faces_textures_computed = false;

    Frame() {     
      //starts with no masks
    }

    void newMask(Mask & newMask) {  
      //create a new mask, 
      //OLD: take the higher id and add 1
      //NEW: return the lower available ID (to be able to reconstruct a lost mask)
      //note: the masks are not necessarily stored in id order
      if (masks.size() == 0) {  
        newMask.maskId = 0;
      } else {
        //newMask.maskId = higherId()+1;
        newMask.maskId = lowerAvailableId();
      }
      masks.push_back(newMask);
    }

    int higherId() { 
      int maxId = 0; 
      for (int i=0; i<masks.size(); i++) {
        if (masks[i].maskId > maxId)
          maxId = masks[i].maskId;
      }
      return maxId;
    }

    int lowerAvailableId() { 
      for (int i=0; i<MAX_MASKS_IDS; i++) {
        if (getMaskById(i) == nullptr)
          return i;
      }
      printf("WARNING: reached MAX_MASKS_IDS, returning 0");
      return 0;
    }

    int getMaskIndexById(int queryId) { 
      for (int i=0; i<masks.size(); i++) {
        if (masks[i].maskId == queryId)
          return i;
      }
      return -1;
    }

    Mask* getMaskById(int queryId) { 
      int idx = getMaskIndexById(queryId);
      if (idx>-1)
        return &masks[idx];
      else
        return nullptr;
      /*for (int i=0; i<masks.size(); i++) {
        if (masks[i].maskId == queryId)
          return &masks[i];
      }
      return nullptr;*/
    }

    bool removeMaskById(int queryId) { 
      int idx = getMaskIndexById(queryId);
      if (idx>-1) {
        masks.erase(masks.begin() + idx);
        return true;
      } else {
        return false;
      }
    }
};

class Video {      
  public:          
    std::vector<Frame> frames; 
    bool loaded = false;
};

#endif
