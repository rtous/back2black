#ifndef __DATASTRUCTURES_H__
#define __DATASTRUCTURES_H__

#include <opencv2/opencv.hpp> 
#include "sam.h"
#include <SDL_opengl.h>

/*
	- A video is composed by frames
	- A frame is composed by masks
	- An mask has one-to-many contours (example: tshirt if the arm divides it)
*/ 

class Contour {      
  public:             
    std::vector<cv::Point> contourPoints;
    cv::Point contourCenter;
};

//class Mask {      
class Mask {      
  public:             
    //pixels
    cv::Mat opencv_mask;//generated by compute_mask in common1.cpp. Used by the editor?
    sam_image_u8 samMask; //mask in sam format
    bool mask_computed = false;
    GLuint maskTexture; //mask in OpenGL
    GLuint simplifiedMaskTexture; //simplified mask in OpenGL
    bool textures_computed = false;
    bool visible = true;

    //contours
    //WHO's using this??
    std::vector<std::vector<cv::Point>> contours;//contours of the mask generated by compute_mask_center

    std::vector<std::vector<cv::Point>> simplifiedContours;//contours of the simplified mask

  
    
    int maskId;
    //int color;
    float color[4]; //R,G,B,A (WARNING: values between 0 and 1)
    int mask_computed_at_x = -1;  
    int mask_computed_at_y = -1;
    int mask_center_x = -1;  
    int mask_center_y = -1; 
    int mask_contour_size;

    Mask() {
      //Default color
      color[0] = (rand() % 256)/(float)256;
      color[1] = (rand() % 256)/(float)256;
      color[2] = (rand() % 256)/(float)256;
      color[3] = 0.0f;//no transparency
    }
};

class Frame {      
  public:             
    int order; //from 0 to N-1 
    bool loaded = false;
    std::string filePath; //when the input is a directory of images instead of a video (only used to keep the filenames in the output in cli_masks)
    std::vector<Mask> masks; 
    cv::Mat img; //OpenCV format
    sam_image_u8 img_sam_format; //the video frame in sam format
    GLuint tex; //OpenGL texture of the original video frame

    Frame() {     
      //starts with no masks
    }

    /*void newMask(Mask newMask) {  
      //create a new mask, take the last id and add 1
      if (masks.size() == 0)   
        newMask.maskId = 0;
      else 
        newMask.maskId = masks[masks.size()-1].maskId+1;
        masks.push_back(newMask);
    }*/
};

class Video {      
  public:          
    std::vector<Frame> frames; 
    bool loaded = false;
};

#endif
